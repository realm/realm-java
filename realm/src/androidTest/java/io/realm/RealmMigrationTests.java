package io.realm;

import android.test.AndroidTestCase;

import java.io.File;
import java.io.IOException;

import io.realm.entities.AllTypes;
import io.realm.entities.Dog;
import io.realm.entities.FieldOrder;
import io.realm.exceptions.RealmMigrationNeededException;
import io.realm.internal.ColumnType;
import io.realm.internal.Table;

public class RealmMigrationTests extends AndroidTestCase {

    public void testRealmClosedAfterMigrationException() throws IOException {
        String REALM_NAME = "default0.realm";
        Realm.deleteRealmFile(getContext(), REALM_NAME);
        TestHelper.copyRealmFromAssets(getContext(), REALM_NAME, REALM_NAME);
        try {
            Realm.getInstance(getContext(), REALM_NAME);
            fail("A migration should be triggered");
        } catch (RealmMigrationNeededException expected) {
            Realm.deleteRealmFile(getContext(), REALM_NAME); // Delete old realm
        }

        // This should recreate the Realm with proper schema
        Realm realm = Realm.getInstance(getContext(), REALM_NAME);
        int result = realm.where(AllTypes.class).equalTo("columnString", "Foo").findAll().size();
        assertEquals(0, result);
    }

    // If a migration creates a different ordering of columns on Realm A, while another ordering is generated by
    // creating a new Realm B. Global column indices will not work. They must be calculated for each Realm.
    public void testGlobalCachedColumnIndicesThrows() throws IOException {
        String MIGRATED_REALM = "migrated.realm";
        String NEW_REALM = "new.realm";

        // Migrate old Realm to proper schema
        Realm.deleteRealmFile(getContext(), MIGRATED_REALM);
        Realm.setSchema(AllTypes.class);
        Realm migratedRealm = Realm.getInstance(getContext(), MIGRATED_REALM);
        migratedRealm.close();
        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), MIGRATED_REALM).getAbsolutePath(), new RealmMigration() {
            @Override
            public long execute(Realm realm, long version) {
                Table languageTable = realm.getTable(FieldOrder.class);
                if (languageTable.getColumnCount() == 0) {
                    languageTable.addColumn(ColumnType.INTEGER, "field2");
                    languageTable.addColumn(ColumnType.BOOLEAN, "field1");
                }

                return version + 1;
            }
        });

        // Open migrated Realm and populate column indices based on migration ordering.
        Realm.setSchema(AllTypes.class, FieldOrder.class);
        migratedRealm = Realm.getInstance(getContext(), MIGRATED_REALM);

        // Create new Realm which will cause column indices to be recalculated based on the order in the java file
        // instead of the migration
        Realm.deleteRealmFile(getContext(), NEW_REALM);
        Realm newRealm = Realm.getInstance(getContext(), NEW_REALM);
        newRealm.close();

        // Try to query migrated realm with newly calculated column indices.
        assertEquals(0, migratedRealm.where(FieldOrder.class).equalTo("field1", true).findAll().size());
    }

    public Realm getRealm(String realmName) {
        Realm instance;
        try {
            instance = Realm.getInstance(getContext(), realmName);
        } catch (RealmMigrationNeededException e) {
            instance = Realm.getInstance(getContext(), realmName);
        }
        return instance;
    }



}
